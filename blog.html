<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Blog Page</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Zilla+Slab:wght@300;400;500&display=swap" rel="stylesheet" />
</head>

<body>
    <h1 class="title">Blog Page</h1>
    <div class="container ">
        <div class="row">
            <div class="col-md-12 text-white blog mb-4">
                <h2>Q. Difference Between localStorage and sessionStorage </h2>
                <h4>localStorage:</h4>
                <h5>The localStorage is an object that helps to store data with no expiration date.
                    Therefore, this data will not be deleted even the browser is closed. In other words,
                    the user can access a page’s local storage without any time limit. So, it is
                    possible to obtain data the next day or after a week or a year.</h5>
                <pre>Refer to the below code.

      localStorage.setItem(“key”, “value”);
      localStorage.getItem('key');
      localStorage.removeItem(“key”);
      localStorage.clear();</pre>

                <h4>sessionStorage:</h4>
                <h5>The functionality of the sessionStorage is similar to localStorage, but it stores
                    data only for one session. Therefore, the data is deleted when the user closes the
                    browser tab. So, it helps to add data to the session storage. It is possible to
                    access it by any page from the same site opened in that window. Once the user closes
                    the window, the session is lost. Likewise, the sessionStorage object allows string
                    data of a specific session.</h5>
                <pre>Refer to the below code.

        sessionStorage.setItem(“key”, “value”);
        sessionStorage.getItem('key');
        sessionStorage.removeItem(“key”);
        sessionStorage.clear();</pre>
            </div>
            <div class="col-md-12 text-white blog mb-4">
                <h2>Q. Difference Between Global Scope and Block Scope</h2>
                <h4>Global Scope:</h4>
                <h5>The variables defined outside of any function or curly brackets are known as global
                    variables and have global scope. Global scope means that the variables can be
                    accessed from any part of that program, any function or conditional state can access
                    that variable.</h5>
                <pre>
        var name = "Md Alamin";
        function globalScope(){
        console.log("This tutorial is by "+name);
          }
        globalScope();</pre>

                <h4>Block Scope:</h4>
                Block scope is also a sub-type of local scope. The block scope can be defined as the
                scope of the variables inside the curly brackets {}. Now, these curly brackets can
                be of loops, or conditional statements, or something else. You are only allowed to
                refer to these variables from within the curly brackets {}. This block of code is
                itself inside a function.</h5>
                <pre>
        function addition() {
           let a = 10;
            const b = 5;
        }
                                </pre>
            </div>
            <div class="col-md-12 text-white blog mb-4">
                <h2>Q. What is an event loop in JavaScript?</h2>
                <h5>The event loop is the secret behind JavaScript’s asynchronous programming. JS executes all
                    operations on a single thread, but using a few smart data structures, it gives us the illusion of
                    multi-threading. Let’s take a look at what happens on the back-end.

                    The call stack is responsible for keeping track of all the operations in line to be executed.
                    Whenever a function is finished, it is popped from the stack.
                    The event queue is responsible for sending new functions to the stack for processing. It follows the queue data structure to maintain the correct sequence in which all operations should be sent for execution.
                </h5>

            </div>
            <div class="col-md-12 text-white blog mb-4">
                <h2>Q. How many ways we can get undefined in Javascript?</h2>
                <h5>1. Undefined represents the value of a variable that hasn't been yet initialized, while null
                    represents an intentional absence of an object. Let's explore the difference in some examples.
                    The variable number is defined, however, is not assigned with an initial value:
                    <pre>
        let number;
        number; // => undefined

        const obj = { firstName: 'Dmitri' };
        bj.lastName; // => undefined
                            </pre>
                    <pre>
        const student = {
            id: 21,
            name: 'Alamin',
            address: 'Dhaka',
            age: 20
        } 
        console.log(student.phone)// => undefined</pre>
                </h5>
                <h5>2. You get undefined when accessing an array element with an out of bounds index
                    <pre>
        const colors = ['blue', 'white', 'red'];
            colors[5];  // => undefined
            colors[-1]; // => undefined</pre>
                </h5>
                <h5>3. Implicitly, without return statement, a JavaScript function returns undefined
                    <pre>
        function myFun(x) {
            const res = x * x;
        }
        myFun(2); // => undefined</pre>
                </h5>
                <h5>4. Sometimes a function does not require the full set of arguments on invocation. You can set
                    defaults for parameters that don't have a value.
                    <pre>
        function myFun(x, y) {
            return  x + y;
        }
        myFun(2); // => undefined</pre>
                </h5>
                <h5>5. If return has nothing on the constion that will return undefined.
                    <pre>
        function ifNegative(x, y) {
            if(x < 0 || y < 0){
                return 
            }
            return x + y;
         }
         const result = ifNegative(2, -8);
         console.log( result)// => undefined</pre>
                </h5>

            </div>
        </div>

    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>
</body>

</html>